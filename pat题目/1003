我要通过！
“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。

得到“答案正确”的条件是：
字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符；
任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；
如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。
现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。

输入格式：
每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (≤10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。
输出格式：
每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。

输入样例：
10
PAT
PAAT
AAPATAA
AAPAATAAAA
xPATx
PT
Whatever
APAAATAA
APT
APATTAA
输出样例：
YES
YES
YES
YES
NO
NO
NO
NO
NO
NO

解题思路：
1.首先判断字符里有没有其他字符（除pat以外的），如果有直接无效
2.字符中只能有一个p和一个t，P必须在T之前，且P和T 不能相连
3.需要结合题目中的递归规则推导,不能单纯以为P和T之间有一两个A就足够了，但是一定要明确PT之间至少一个A：设 P 前面的 A 数量为 a（可为 0）。设 P 和 T 之间的 A 数量为 b（必须 ≥1）。设 T 后面的 A 数量为 c（可为 0）。
根据题目规则，必须满足 a * b = c。
（例如：PAT 中 a=0, b=1, c=0 → 0*1=0 有效；AAPATAA 中 a=2, b=1, c=2 → 2*1=2 有效；AAPAATAAAA 中 a=2, b=2, c=4 → 2*2=4 有效）。

根据思路写代码（PYTHON）：
n=int(input())
for _ in range(n):#这里使用_而不是普通变量名（如i），是因为我们只需要循环n次，并不关心当前循环到了第几次
  s=input().strip()#循环输入字符串
# 条件1：只包含P、A、T三种字符
  if not set(s).issubset({'P','A','T'}):#set()函数是将S转换为集合，然后包含所有不重复的字符
                                        #issubet()函数是集合的一个方法，用来判断当前集合是否是另一个集合的子集，如果set(s)中的所有元素都在{'P', 'A', 'T'}中，那么set(s).issubset(...)返回True
    print("NO")
    continue
# 条件2：必须有且仅有一个P和一个T
    if s.count('P') != 1 or s.count('T') != 1:#count()函数就是计算字符串中（）中字符个数，注意形式，s.count('P')  or s.count('T') != 1会导致逻辑错误
        print("NO")
        continue#之后的就是字符串中仅有一个P和一个T
    # 找到P和T的位置
    p_pos = s.index('P')#index()是字符串的方法，用于查找指定字符在字符串中第一次出现的位置（索引），这里会返回P在字符串s中第一次出现的索引值，赋值给变量p_pos
    t_pos = s.index('T')
    # 确保P在T之前
    if p_pos >= t_pos:#用于检查 P 是否位于 T 的位置之后
        print("NO")
        continue
# 条件3：P和T之间至少有一个A(必须明确）
    between = t_pos - p_pos - 1
    if between <= 0:
        print("NO")
        continue
    # 计算a、b、c的值
    a = p_pos  # P前面A的数量
    b = between  # P和T之间A的数量
    c = len(s) - t_pos - 1  # T后面A的数量
# 条件4：检查a * b是否等于c
    if a * b == c:
        print("YES")
    else:
        print("NO")
